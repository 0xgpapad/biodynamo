#ifndef CELL_H_
#define CELL_H_

#include <array>
#include <cmath>
#include <type_traits>

#include "backend.h"
#include "cell.h"
#include "default_force.h"
#include "inline_vector.h"
#include "math_util.h"
#include "param.h"
// #include "simulation_object.h"
// #include "simulation_object_util.h"

namespace bdm {

using std::array;
using std::enable_if;
using std::is_same;

template <typename Backend=Scalar>
class Cell {
 public:
// this code block will later be generated by the BDM_CLASS_HEADER macro
// BDM_CLASS_HEADER(Cell, position_, mass_location_, tractor_force, diameter_,
//     volume_, adherence_, mass_, neighbors_)
  template <typename T>
  friend class Cell;

  template <typename T>
  using vec = typename Backend::template vec<T>;

  size_t size() const { return position_.size(); }

  Cell<SoaRef> operator[](size_t idx) {
    return Cell<SoaRef>(this, idx);
  }

  const Cell<SoaRef> operator[](size_t idx) const {
    return Cell<SoaRef>(const_cast<Cell<Backend>*>(this), idx);
  }

  void push_back(const Cell<Scalar>& cell) {
    position_.push_back(cell.position_[0]);
    mass_location_.push_back(cell.mass_location_[0]);
    tractor_force_.push_back(cell.tractor_force_[0]);
    diameter_.push_back(cell.diameter_[0]);
    volume_.push_back(cell.volume_[0]);
    adherence_.push_back(cell.adherence_[0]);
    mass_.push_back(cell.mass_[0]);
    neighbors_.push_back(cell.neighbors_[0]);
  }

  void reserve(size_t capacity) {
    position_.reserve(capacity);
    mass_location_.reserve(capacity);
    tractor_force_.reserve(capacity);
    diameter_.reserve(capacity);
    volume_.reserve(capacity);
    adherence_.reserve(capacity);
    mass_.reserve(capacity);
    neighbors_.reserve(capacity);
  }

  template <typename T>
  Cell(T* other, size_t idx)
        : idx_(idx),
          position_(other->position_),
          mass_location_(other->mass_location_),
          tractor_force_(other->tractor_force_),
          diameter_(other->diameter_),
          volume_(other->volume_),
          adherence_(other->adherence_),
          mass_(other->mass_),
          neighbors_(other->neighbors_) {}
// end BDM_CLASS_HEADER code block


  Cell() {}
  explicit Cell(double diameter) : diameter_(diameter) { UpdateVolume(); }
  explicit Cell(const array<double, 3>& position)
      : position_(position), mass_location_(position) {}
  virtual ~Cell() {}

  double GetAdherence() const { return adherence_[idx_]; }

  double GetDiameter() const { return diameter_[idx_]; }

  double GetMass() const { return mass_[idx_]; }

  const array<double, 3>& GetMassLocation() const {
    return mass_location_[idx_];
  }

  const array<double, 3>& GetPosition() const { return position_[idx_]; }

  const array<double, 3>& GetTractorForce() const {
    return tractor_force_[idx_];
  }

  double GetVolume() const { return volume_[idx_]; }

  const InlineVector<int, 8>& GetNeighbors() const { return neighbors_[idx_]; }

  void SetAdherence(double adherence) { adherence_[idx_] = adherence; }

  void SetDiameter(double diameter) { diameter_[idx_] = diameter; }

  void SetMass(double mass) { mass_[idx_] = mass; }

  void SetMassLocation(const array<double, 3>& mass_location) {
    mass_location_[idx_] = mass_location;
  }

  void SetPosition(const array<double, 3>& position) {
    position_[idx_] = position;
  }

  void SetTractorForce(const array<double, 3>& tractor_force) {
    tractor_force_[idx_] = tractor_force;
  }

  void SetNeighbors(const InlineVector<int, 8>& neighbors) {
    neighbors_[idx_] = neighbors;
  }

  void ChangeVolume(double speed) {
    // scaling for integration step
    double dV = speed * Param::kSimulationTimeStep;
    volume_[idx_] += dV;
    if (volume_[idx_] < 5.2359877E-7) {
      volume_[idx_] = 5.2359877E-7;
    }
    UpdateDiameter();
  }

  void UpdateDiameter() {
    // V = (4/3)*pi*r^3 = (pi/6)*diameter^3
    diameter_[idx_] = std::cbrt(volume_[idx_] * 6 / Math::kPi);
  }

  void UpdateVolume() {
    volume_[idx_] =
        Math::kPi / 6 * diameter_[idx_] * diameter_[idx_] * diameter_[idx_];
  }

  void UpdateMassLocation(const array<double, 3>& delta) {
    mass_location_[idx_][0] += delta[0];
    mass_location_[idx_][1] += delta[1];
    mass_location_[idx_][2] += delta[2];
  }

  void GetForceOn(const array<double, 3>& ref_mass_location,
                  double ref_diameter, array<double, 3>* force) const {
    DefaultForce default_force;
    double iof_coefficient = Param::kSphereDefaultInterObjectCoefficient;

    default_force.forceBetweenSpheres(ref_mass_location, ref_diameter,
                                      iof_coefficient, mass_location_[idx_],
                                      diameter_[idx_], iof_coefficient, force);
  }

 private:
  mutable size_t idx_ = 0;
  vec<array<double, 3>> position_;
  vec<array<double, 3>> mass_location_;
  vec<array<double, 3>> tractor_force_;
  vec<double> diameter_;
  vec<double> volume_;
  vec<double> adherence_;
  vec<double> mass_;

  // stores a list of neighbor ids for each scalar cell
  vec<InlineVector<int, 8>> neighbors_;
};

}  // namespace bdm

#endif  // CELL_H_
